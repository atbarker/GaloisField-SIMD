/* Austen Barker (2019) */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/random.h>
#include <linux/slab.h>
#include <linux/vmalloc.h>
#include <linux/time.h>
#include <linux/types.h>
#include "cauchy_rs.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("AUSTEN BARKER");

#define BLOCK_BYTES 4096
#define ORIGINAL_COUNT 4
#define RECOVERY_COUNT 4

int ExampleFileUsage(void)
{   
    cauchy_encoder_params params;
    int i, ret;
    struct timespec timespec1, timespec2;
    uint8_t** dataBlocks = kmalloc(sizeof(uint8_t*) * ORIGINAL_COUNT, GFP_KERNEL);
    uint8_t** dataBlocksCopy = kmalloc(sizeof(uint8_t*) * ORIGINAL_COUNT, GFP_KERNEL);
    uint8_t** recoveryArray = kmalloc(sizeof(uint8_t*) * RECOVERY_COUNT, GFP_KERNEL);
    for(i = 0; i < RECOVERY_COUNT; i++){
        recoveryArray[i] = kmalloc(BLOCK_BYTES, GFP_KERNEL);
    }

    for(i = 0; i < ORIGINAL_COUNT; i++){
        dataBlocks[i] = kmalloc(BLOCK_BYTES, GFP_KERNEL);
	dataBlocksCopy[i] = kmalloc(BLOCK_BYTES, GFP_KERNEL);
	get_random_bytes(dataBlocks[i], BLOCK_BYTES);\
	memcpy(dataBlocksCopy[i], dataBlocks[i], BLOCK_BYTES);
    }

    if (cauchy_init())
    {
        printk(KERN_INFO "Initialization messed up\n");
        return 1;
    }
    printk(KERN_INFO "Initialized\n");

    // Number of bytes per file block
    params.BlockBytes = BLOCK_BYTES;

    // Number of blocks
    params.OriginalCount = ORIGINAL_COUNT;

    // Number of additional recovery blocks generated by encoder
    params.RecoveryCount = RECOVERY_COUNT;

    // Recovery data
    //recoveryBlocks = kmalloc(params.RecoveryCount * params.BlockBytes, GFP_KERNEL);

    // Generate recovery data
    getnstimeofday(&timespec1);
    ret = cauchy_rs_encode(params, dataBlocks, recoveryArray);
    
    if(ret){
        printk("Error when encoding %d\n", ret);
        return 1;
    }
    getnstimeofday(&timespec2);
    printk(KERN_INFO "Encode took: %ld nanoseconds",
(timespec2.tv_sec - timespec1.tv_sec) * 1000000000 + (timespec2.tv_nsec - timespec1.tv_nsec));

    /*    
    // Initialize the indices
    for (i = 0; i < params.OriginalCount; ++i)
    {
        blocks[i].Index = cauchy_get_original_block_index(params, i);
    }

    //// Simulate loss of data, subsituting a recovery block in its place ////
    blocks[0].Block = recoveryArray[0]; // First recovery block
    blocks[0].Index = cauchy_get_recovery_block_index(params, 0); // First recovery block index
    //// Simulate loss of data, subsituting a recovery block in its place ////
    
    blocks[1].Block = recoveryArray[1];
    blocks[1].Index = cauchy_get_recovery_block_index(params, 1);

    getnstimeofday(&timespec1);    
    ret = cauchy_rs_decode(params, blocks);
    getnstimeofday(&timespec2);
    printk(KERN_INFO "Decode took: %ld nanoseconds",
(timespec2.tv_sec - timespec1.tv_sec) * 1000000000 + (timespec2.tv_nsec - timespec1.tv_nsec));\

    if (ret)
    {
	printk(KERN_INFO "decode failed %d \n", ret);
        return 1;
    }

    
    for(i = 0; i < 2 * 4096; i++){
        if(blocks[i/4096].Block[i%4096] != filedatacopy[i]){
            printk(KERN_INFO "Decode errors on byte %d\n", i);
	    return -1;
	}
    }

    printk(KERN_INFO "decode worked\n");
    */

    kfree(dataBlocks);
    kfree(dataBlocksCopy);
    //kfree(recoveryBlocks);
    kfree(recoveryArray);
    return 0;
}

static int __init km_template_init(void){
    ExampleFileUsage();
    printk(KERN_INFO "Kernel Module inserted");
    return 0;
}

static void __exit km_template_exit(void){
    printk(KERN_INFO "Removing kernel module\n");
}

module_init(km_template_init);
module_exit(km_template_exit);
